//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 4.0.1
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace nrt
{

    /// @brief Indicates the result status of NRT API execution
    public enum Status
    {
        /// Success without any problems
        STATUS_SUCCESS = 0,
        /// Use wrong value as function or method input
        STATUS_ERROR_INVALID_VALUE = 1,
        /// Errors due to OS or other system issues
        STATUS_ERROR_SYSTEM = 2,
        /// Error for unknown reason
        STATUS_ERROR_UNKNOWN = 999
    }

}
namespace nrt
{

    /// @brief Indicates data
    public enum DType
    {
        DTYPE_NONE = 0, /*!< Invalid data type value*/
        DTYPE_INT8 = 1, /*!< Represents an 8 - bit integer(char) */
        DTYPE_UINT8 = 2, /*!< Represents an 8 - bit unsigned integer( unsigned char) */
        DTYPE_INT16 = 3, /*!<  Represents an 16 - bit integer(short) */
        DTYPE_UINT16 = 4, /*!<  Represents an 16 - bit unsigned integer(unsigned short) */
        DTYPE_INT32 = 5, /*!<  Represents an 32 - bit integer(int) */
        DTYPE_UINT32 = 6, /*!< Represents an 32 - bit unsigned integer(unsigned int) */
        DTYPE_INT64 = 7, /*!< Represents an 64 - bit integer(long long) */
        DTYPE_UINT64 = 8, /*!< Represents an 64 - bit unsigned integer(unsigned long long) */
        DTYPE_FLOAT16 = 9, /*!< Represents an 16 - bit half precision float */
        DTYPE_FLOAT32 = 10, /*!<  Represents an 32- bit floating-point (float) */
        DTYPE_FLOAT64 = 11, /*!<  Represents an 64 - bit floating-point (double) */
    }

}
namespace nrt
{
    /// @brief Represents the method to use when interpolating in resize or other functions.
    public enum InterpolationType
    {
        /// Invalid interpolation type value
        INTER_NONE = 0,
        /// Nearest interpolation type
        INTER_NEAREST = 1,
        /// Bi-linear interpolation type
        INTER_LINEAR = 2,
        /// Area device type value
        INTER_AREA = 3,
        /// Bi-cubic interpolation type
        INTER_CUBIC = 4,
    }

}
namespace nrt
{
    /// @brief Indicates the shape of the data\n
    /// In the case of an image, the shape is represented by [height, width, 3].\n
    /// Multiple images are represented by the following shapes. [num_of_images, height, width, channel]\n
    /// The number of dimensions in the shape is represented by the num_dim member variable, 
    /// and the value at each index in the dims[] represents the value on that axis.\n
    public class Shape : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal Shape(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Shape obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Shape()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_Shape(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        public Shape() : this(nrtPINVOKE.new_Shape__SWIG_0(), true)
        {
        }

        public Shape(int d0) : this(nrtPINVOKE.new_Shape__SWIG_1(d0), true)
        {
        }

        public Shape(int d0, int d1) : this(nrtPINVOKE.new_Shape__SWIG_2(d0, d1), true)
        {
        }

        public Shape(int d0, int d1, int d2) : this(nrtPINVOKE.new_Shape__SWIG_3(d0, d1, d2), true)
        {
        }

        public Shape(int d0, int d1, int d2, int d3) : this(nrtPINVOKE.new_Shape__SWIG_4(d0, d1, d2, d3), true)
        {
        }

        /// @brief Get the value of the axis.\n
		/// @param axis_index Index of axis to get value
        public int get_axis(int axis_index)
        {
            int ret = nrtPINVOKE.Shape_get_axis(swigCPtr, axis_index);
            return ret;
        }

        /// @brief Assign values to axis\n
		/// @param axis_index axis_index Index of axis to set value
		/// @param value Value to be set for the axis
        public void set_axis(int axis_index, int value)
        {
            nrtPINVOKE.Shape_set_axis(swigCPtr, axis_index, value);
        }

        /// @brief Expand the shape to batch shape\n
		/// Expand the shape by putting the batch axis in front of the current shape.\n
		/// (example. [64, 64, 3] => [batch_size, 64, 64 ,3])\n
        public Shape to_batch_shape(int batch_size)
        {
            Shape ret = new Shape(nrtPINVOKE.Shape_to_batch_shape(swigCPtr, batch_size), true);
            return ret;
        }

        public int num_dim
        {
            set
            {
                nrtPINVOKE.Shape_num_dim_set(swigCPtr, value);
            }
            get
            {
                int ret = nrtPINVOKE.Shape_num_dim_get(swigCPtr);
                return ret;
            }
        }

        public static readonly int DIM_UNKNOWN = nrtPINVOKE.Shape_DIM_UNKNOWN_get();

        public static readonly int MAX_DIM = nrtPINVOKE.Shape_MAX_DIM_get();
    }

}
namespace nrt
{
    /// @brief Buffer class to hold memory space for data I/O\n
    /// It has shape and dtype and corresponding memory space\n
    /// Data is stored in a contiguous memory space\n
    /// The layout of the data represented by the shape is Equivalent to a memory order like a C multidimensional array.
    /// example.\n
    /// If it has a shape of[2, 3], the data is saved in the following order. \n
    ///	A[0, 0], A[0, 1], A[0, 2], A[1, 0], A[1, 1], A[1, 2]\n
    /// Data memory space is managed by reference counter. Automatically released when the last reference is destroyed
    public class NDBuffer : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal NDBuffer(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(NDBuffer obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~NDBuffer()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_NDBuffer(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        public NDBuffer() : this(nrtPINVOKE.new_NDBuffer__SWIG_0(), true)
        {
        }

        public NDBuffer(Shape _shape, DType _dtype, bool zeroInit) : this(nrtPINVOKE.new_NDBuffer__SWIG_1(Shape.getCPtr(_shape), (int)_dtype, zeroInit), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public NDBuffer(Shape _shape, DType _dtype) : this(nrtPINVOKE.new_NDBuffer__SWIG_2(Shape.getCPtr(_shape), (int)_dtype), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public NDBuffer(Shape _shape) : this(nrtPINVOKE.new_NDBuffer__SWIG_3(Shape.getCPtr(_shape)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public NDBuffer(byte[] buff, ulong buff_size, Shape _shape, DType _dtype) : this(nrtPINVOKE.new_NDBuffer__SWIG_4(buff, buff_size, Shape.getCPtr(_shape), (int)_dtype), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public NDBuffer(byte[] buff, ulong buff_size, Shape _shape) : this(nrtPINVOKE.new_NDBuffer__SWIG_5(buff, buff_size, Shape.getCPtr(_shape)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public static NDBuffer zeros(Shape _shape, DType _dtype)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_zeros(Shape.getCPtr(_shape), (int)_dtype), true);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Create a buffer to set the size threshold. The created buffer is used as a function argument such as pred_map_threshold_by_size().
        /// @param height_thres Height threshold
        /// @param width_thres Width threshold
        /// @param thres_cond threshold condition\n
        ///    Case thres_cond == 0, it changes to background when the size of the detected area satisfies both height_thres and width_thres. (AND condition)\n
        ///	   Case thres_cond == 1, it changes to the background area when the size of the detected area satisfies either height_thres or width_thres. (OR condition)\n
        public static NDBuffer make_size_thres(int height_thres, int width_thres, int thres_cond)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_make_size_thres(height_thres, width_thres, thres_cond), true);
            return ret;
        }

        public NDBuffer(NDBuffer src) : this(nrtPINVOKE.new_NDBuffer__SWIG_6(NDBuffer.getCPtr(src)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.
        /// @param buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of bytes.
        /// @return The size of the data that was actually copied.
        public int copy_to_buffer(byte[] buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer__SWIG_0(swigCPtr, buff, buff_size);
            return ret;
        }

        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of bytes.
        /// @return The size of the data that was actually copied.
        public int copy_from_buffer(byte[] buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer__SWIG_0(swigCPtr, buff, buff_size);
            return ret;
        }

        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of bytes.
        /// @return The size of the data that was actually copied.
        public int copy_to_buffer(int idx0, byte[] buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer__SWIG_1(swigCPtr, idx0, buff, buff_size);
            return ret;
        }

        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of bytes.
        /// @return The size of the data that was actually copied.
        public int copy_from_buffer(int idx0, byte[] buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer__SWIG_1(swigCPtr, idx0, buff, buff_size);
            return ret;
        }

        /// @brief Returns the total number of elements in the buffer.\n
        public ulong get_total_size()
        {
            ulong ret = nrtPINVOKE.NDBuffer_get_total_size(swigCPtr);
            return ret;
        }

        /// @brief Returns the total number of bytes in the buffer.That is, the total number of elements * sizeof(type).\n
        public ulong get_byte_size()
        {
            ulong ret = nrtPINVOKE.NDBuffer_get_byte_size(swigCPtr);
            return ret;
        }

        public global::System.IntPtr get_data_ptr()
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_data_ptr(swigCPtr);
            return ret;
        }

        public global::System.IntPtr get_at_ptr(int idx0, int idx1, int idx2, int idx3)
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_at_ptr__SWIG_0(swigCPtr, idx0, idx1, idx2, idx3);
            return ret;
        }

        public global::System.IntPtr get_at_ptr(int idx0, int idx1, int idx2)
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_at_ptr__SWIG_1(swigCPtr, idx0, idx1, idx2);
            return ret;
        }

        public global::System.IntPtr get_at_ptr(int idx0, int idx1)
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_at_ptr__SWIG_2(swigCPtr, idx0, idx1);
            return ret;
        }

        public global::System.IntPtr get_at_ptr(int idx0)
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_at_ptr__SWIG_3(swigCPtr, idx0);
            return ret;
        }

        public global::System.IntPtr get_at_ptr()
        {
            global::System.IntPtr ret = nrtPINVOKE.NDBuffer_get_at_ptr__SWIG_4(swigCPtr);
            return ret;
        }

        public DType get_dtype()
        {
            DType ret = (DType)nrtPINVOKE.NDBuffer_get_dtype(swigCPtr);
            return ret;
        }

        public Shape get_shape()
        {
            Shape ret = new Shape(nrtPINVOKE.NDBuffer_get_shape(swigCPtr), false);
            return ret;
        }

        public NDBuffer clone()
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_clone(swigCPtr), true);
            return ret;
        }

        public void reset(Shape _shape, DType _dtype)
        {
            nrtPINVOKE.NDBuffer_reset__SWIG_0(swigCPtr, Shape.getCPtr(_shape), (int)_dtype);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public void reset(Shape _shape)
        {
            nrtPINVOKE.NDBuffer_reset__SWIG_1(swigCPtr, Shape.getCPtr(_shape));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public bool empty()
        {
            bool ret = nrtPINVOKE.NDBuffer_empty(swigCPtr);
            return ret;
        }

        public static NDBuffer int64(long value)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_int64(value), true);
            return ret;
        }

        public static NDBuffer load_image(string image_path)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_load_image(image_path), true);
            return ret;
        }

        /// @brief It takes an multiple image paths and resizes it into a target shape, making it an NDBuffer and returning it.
        /// @param target_shape Target shape value to resize. It must be three-dimensional and have the form [height, width, channel]\n
        /// The current version only supports 3 channel or 1channel images, so the value of the last dimension must be 3 or 1.\n
        /// @param image_paths Multiple image paths. Each image path must be separated by a newline.\n
        /// example. "C:/path/image1.png\nC:/path/image2.png\n"
        /// @param resize_method Indicates the interpolation method to use for resize
        /// @return The image loaded NDBuffer is returned.\n
        /// The shape of the buffer returned according to the input is as follows.\n
        /// [number_of_image, target_height, target_width, target_channel] 
        /// If image loading fails, an empty NDbuffer is returned.
        public static NDBuffer load_images(Shape target_shape, string image_paths, InterpolationType resize_method)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_load_images__SWIG_0(Shape.getCPtr(target_shape), image_paths, (int)resize_method), true);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief It takes an multiple image paths and resizes it into a target shape, making it an NDBuffer and returning it.
        /// @param target_shape Target shape value to resize. It must be three-dimensional and have the form [height, width, channel]\n
        /// The current version only supports 3 channel or 1channel images, so the value of the last dimension must be 3 or 1.\n
        /// @param image_paths Multiple image paths. Each image path must be separated by a newline.\n
        /// example. "C:/path/image1.png\nC:/path/image2.png\n"
        /// @return The image loaded NDBuffer is returned.\n
        /// The shape of the buffer returned according to the input is as follows.\n
        /// [number_of_image, target_height, target_width, target_channel] 
        /// If image loading fails, an empty NDbuffer is returned.
        public static NDBuffer load_images(Shape target_shape, string image_paths)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBuffer_load_images__SWIG_1(Shape.getCPtr(target_shape), image_paths), true);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public void _dbg_show()
        {
            nrtPINVOKE.NDBuffer__dbg_show(swigCPtr);
        }

        public void _dbg_colormap_show()
        {
            nrtPINVOKE.NDBuffer__dbg_colormap_show(swigCPtr);
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint8(byte[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint8__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint8(int idx0, byte[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint8__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int16(short[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int16__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int16(int idx0, short[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int16__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint16(ushort[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint16__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint16(int idx0, ushort[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint16__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int32(int[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int32__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int32(int idx0, int[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int32__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint32(uint[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint32__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint32(int idx0, uint[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint32__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int64(long[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int64__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_int64(int idx0, long[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_int64__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint64(ulong[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint64__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_uint64(int idx0, ulong[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_uint64__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_float32(float[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_float32__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_float32(int idx0, float[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_float32__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data from the input buffer to the NDBuffer object.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_float64(double[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_float64__SWIG_0(swigCPtr, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy data from the input buffer to the index position of the NDBuffer object.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param src_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_from_buffer_float64(int idx0, double[] src_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_from_buffer_float64__SWIG_1(swigCPtr, idx0, src_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint8(byte[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint8__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint8(int idx0, byte[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint8__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int16(short[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int16__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int16(int idx0, short[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int16__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint16(ushort[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint16__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint16(int idx0, ushort[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint16__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int32(int[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int32__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int32(int idx0, int[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int32__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint32(uint[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint32__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint32(int idx0, uint[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint32__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int64(long[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int64__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_int64(int idx0, long[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_int64__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint64(ulong[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint64__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_uint64(int idx0, ulong[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_uint64__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_float32(float[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_float32__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_float32(int idx0, float[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_float32__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data of the NDBuffer object to the input buffer.\n
        /// It will not be copied beyond the allocated size corresponding to the NDBuffer's shape and dtype.\n
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_float64(double[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_float64__SWIG_0(swigCPtr, dst_buff, buff_size);
            return ret;
        }
        /// @brief Copy the data corresponding to the index position of the NDBuffer object into the input buffer.\n
        /// The actual copied size is the size corresponding to the shape and dtype excluding the first axis.\n
        /// In many cases, the first index represents a batch, so it is mainly used to move data to each element in the batch.\n
        /// @param idx0 Index of first axis
        /// @param dst_buff Start address of the input buffer.
        /// @param buff_size The size of the buffer. Number of elements.
        /// @return The size of the data that was actually copied. If the type is different from the dtype of the buffer, return -1 and exit.
        public int copy_to_buffer_float64(int idx0, double[] dst_buff, ulong buff_size)
        {
            int ret = nrtPINVOKE.NDBuffer_copy_to_buffer_float64__SWIG_1(swigCPtr, idx0, dst_buff, buff_size);
            return ret;
        }

    }

}
namespace nrt
{
    /// @brief Class to hold multiple NDBuffers
    /// NDbuffers with different shapes and dtypes can have as elements
    /// Data memory space is managed by reference counter. Automatically released when the last reference is destroyed
    public class NDBufferList : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal NDBufferList(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(NDBufferList obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~NDBufferList()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_NDBufferList(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        public NDBufferList() : this(nrtPINVOKE.new_NDBufferList__SWIG_0(), true)
        {
        }

        public NDBufferList(NDBufferList src) : this(nrtPINVOKE.new_NDBufferList__SWIG_1(NDBufferList.getCPtr(src)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public ulong get_count()
        {
            ulong ret = nrtPINVOKE.NDBufferList_get_count(swigCPtr);
            return ret;
        }

        public void append(NDBuffer ndbuffer)
        {
            nrtPINVOKE.NDBufferList_append(swigCPtr, NDBuffer.getCPtr(ndbuffer));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public NDBuffer get_at(int idx1)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.NDBufferList_get_at__SWIG_0(swigCPtr, idx1), false);
            return ret;
        }

        public NDBuffer get_data_ptr()
        {
            global::System.IntPtr cPtr = nrtPINVOKE.NDBufferList_get_data_ptr__SWIG_0(swigCPtr);
            NDBuffer ret = (cPtr == global::System.IntPtr.Zero) ? null : new NDBuffer(cPtr, false);
            return ret;
        }

        public void resize(int size)
        {
            nrtPINVOKE.NDBufferList_resize(swigCPtr, size);
        }

        public void clear()
        {
            nrtPINVOKE.NDBufferList_clear(swigCPtr);
        }

    }

}
namespace nrt
{
    /// @brief Represents the concrete device type of the Device class
    public enum DevType
    {
        /// Invalid device type value
        DEVICE_NONE = 0,
        /// Represents a cpu device
        DEVICE_CPU = 1,
        /// Represents a cuda-capable GPU device.
        DEVICE_CUDA_GPU = 2
    }

}
namespace nrt
{
    /// @brief Device descriptor class
    public class Device : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal Device(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Device obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Device()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_Device(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        public DevType devtype
        {
            set
            {
                nrtPINVOKE.Device_devtype_set(swigCPtr, (int)value);
            }
            get
            {
                DevType ret = (DevType)nrtPINVOKE.Device_devtype_get(swigCPtr);
                return ret;
            }
        }

        public int id
        {
            set
            {
                nrtPINVOKE.Device_id_set(swigCPtr, value);
            }
            get
            {
                int ret = nrtPINVOKE.Device_id_get(swigCPtr);
                return ret;
            }
        }

        public static int get_num_devices()
        {
            int ret = nrtPINVOKE.Device_get_num_devices();
            return ret;
        }

        public static Device get_device(int index)
        {
            Device ret = new Device(nrtPINVOKE.Device_get_device(index), true);
            return ret;
        }

        public static int get_num_gpu_devices()
        {
            int ret = nrtPINVOKE.Device_get_num_gpu_devices();
            return ret;
        }

        public static Status get_gpu_mem_info(int gid, ref ulong free_mem, ref ulong total_mem)
        {
            Status ret = (Status)nrtPINVOKE.Device_get_gpu_mem_info(gid, ref free_mem, ref total_mem);
            return ret;
        }

        /// @brief Returns the device name.
        public string get_device_name()
        {
            string ret = nrtPINVOKE.Device_get_device_name(swigCPtr);
            return ret;
        }

        public Device() : this(nrtPINVOKE.new_Device(), true)
        {
        }

    }

}
namespace nrt
{
    /// @brief Key Value Data Structure Classes
    /// Used for data input and output.
    /// Key is of type string and value is of type NDbuffer
    /// Data memory space is managed by reference counter. Automatically released when the last reference is destroyed
    public class Dict : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal Dict(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Dict obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Dict()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_Dict(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        public Dict() : this(nrtPINVOKE.new_Dict__SWIG_0(), true)
        {
        }

        public Dict(Dict src) : this(nrtPINVOKE.new_Dict__SWIG_1(Dict.getCPtr(src)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public Status put(string key, NDBuffer val)
        {
            Status ret = (Status)nrtPINVOKE.Dict_put(swigCPtr, key, NDBuffer.getCPtr(val));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public bool has_key(string key)
        {
            bool ret = nrtPINVOKE.Dict_has_key(swigCPtr, key);
            return ret;
        }

        public NDBuffer get(string key)
        {
            NDBuffer ret = new NDBuffer(nrtPINVOKE.Dict_get(swigCPtr, key), false);
            return ret;
        }

        public Status remove(string key)
        {
            Status ret = (Status)nrtPINVOKE.Dict_remove(swigCPtr, key);
            return ret;
        }

        public ulong get_count()
        {
            ulong ret = nrtPINVOKE.Dict_get_count(swigCPtr);
            return ret;
        }

        public void clear()
        {
            nrtPINVOKE.Dict_clear(swigCPtr);
        }

    }

}
namespace nrt
{

    public enum PaddingOpt
    {
        PADD_BOTTOM_RIGHT = 0,
        PADD_CENTER = 1
    }

}
namespace nrt
{
    /// @brief Represents the type according to model input / output.
    public enum ModelType
    {
        /// Default value. Represents an untyped model.
        NONE = 0,
        /// Model that performs Classification
        CLASSIFICATION = 1,
        /// Segmentation model that detects pixel area
        SEGMENTATION = 2,
        /// Object detection model to detect the box area
        DETECTION = 3,
        /// OCR model for character recognition
        OCR = 4
    }

}
namespace nrt
{
    /// @brief Model class\n
	/// This class requires a trained model file to instantiate.
    public class Model : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal Model(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Model obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Model()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_Model(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }
        /// @brief Constructor
        /// @param modelpath The path of the model file.
        /// @param output_opt Specifies the value to use for input and output of the model.\n 
        /// In most cases, you can use the MODELIO_DEFAULT value.\n
        /// In models such as classification and segmentation detection, MODELIO_IN_IMAGE and MODELIO_OUT_PRED flags are set automatically by default.
        /// And if necessary, use flags by oring flags as needed. example. (MODELIO_OUT_PROB | MODELIO_OUT_CAM)
        public Model(string modelpath, int output_opt) : this(nrtPINVOKE.new_Model__SWIG_0(modelpath, output_opt), true)
        {
        }

        /// @brief Constructor
        /// @param modelpath The path of the model file.
        public Model(string modelpath) : this(nrtPINVOKE.new_Model__SWIG_1(modelpath), true)
        {
        }

        public Model(Model src) : this(nrtPINVOKE.new_Model__SWIG_2(Model.getCPtr(src)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        /// @brief Returns the model type value
        public ModelType get_model_type()
        {
            ModelType ret = (ModelType)nrtPINVOKE.Model_get_model_type(swigCPtr);
            return ret;
        }

        public Status get_status()
        {
            Status ret = (Status)nrtPINVOKE.Model_get_status(swigCPtr);
            return ret;
        }

        /// @brief Returns the number of inputs in this model
        public int get_num_inputs()
        {
            int ret = nrtPINVOKE.Model_get_num_inputs(swigCPtr);
            return ret;
        }
        /// @brief Return the shape of the input corresponding to the index argument.
		/// @param input_index The index value in the range [0, num_inputs)
        public Shape get_input_shape(int input_index)
        {
            Shape ret = new Shape(nrtPINVOKE.Model_get_input_shape(swigCPtr, input_index), true);
            return ret;
        }
        /// @brief Return the Data Type of the input corresponding to the index argument.
        /// @param input_index The index value in the range [0, num_inputs)
        public DType get_input_dtype(int input_index)
        {
            DType ret = (DType)nrtPINVOKE.Model_get_input_dtype(swigCPtr, input_index);
            return ret;
        }


        public string get_input_name(int input_index)
        {
            string ret = nrtPINVOKE.Model_get_input_name(swigCPtr, input_index);
            return ret;
        }
        /// @brief Returns the interpolation method used in the training
        public InterpolationType get_InterpolationType(int input_index)
        {
            InterpolationType ret = (InterpolationType)nrtPINVOKE.Model_get_InterpolationType(swigCPtr, input_index);
            return ret;
        }
        /// @brief Check if the corresponding input is in patch mode.\n
		/// If the patch mode value is true, the model training is done in patch units, so it must be divided into appropriate patches before entering the model.\n
		///     In patch mode, the original image is trained after resizing according to the scale factor value.\n
	    ///     After checking scale_factor with get_scale_factor(), you must use the resize function that receives scale_factor as input or resize it to the following size.\n
		///     resize_height = int(original_height * scale_factor)\n
		///     resize_width = int(original_width * scale_factor)\n
		///     The execution procedure is as follows and refer to the example code for details.\n
		///     nrt::resize() // with scale_factor\n
		///     extract_patches_to_target_shape()\n
		///     executor.excuite()\n
		///	    merge_patches_to_orginal_shape()\n
		/// If the patch mode value is false,  the patch separation process is not necessary.\n
		/// In this case, if the original image and the model input size are different, it must be resized to the model input size through the resize method.
        public bool is_patch_mode(int input_index)
        {
            bool ret = nrtPINVOKE.Model_is_patch_mode(swigCPtr, input_index);
            return ret;
        }
        /// @brief Used when the return value of is_patch_mode () is true. In this case, you should scale it according to scale_factor before separating it into patches.
        public float get_scale_factor()
        {
            float ret = nrtPINVOKE.Model_get_scale_factor(swigCPtr);
            return ret;
        }
        /// @brief Returns the number of outputs in this model
        public int get_num_outputs()
        {
            int ret = nrtPINVOKE.Model_get_num_outputs(swigCPtr);
            return ret;
        }
        /// @brief Return the shape of the output corresponding to the index argument.
        /// @param output_index The index value in the range [0, num_outputs)
        public Shape get_output_shape(int output_index)
        {
            Shape ret = new Shape(nrtPINVOKE.Model_get_output_shape(swigCPtr, output_index), true);
            return ret;
        }
        /// @brief Return the Data Type of the output corresponding to the index argument.
        /// @param output_index The index value in the range [0, num_outputs)
        public DType get_output_dtype(int output_index)
        {
            DType ret = (DType)nrtPINVOKE.Model_get_output_dtype(swigCPtr, output_index);
            return ret;
        }

        public string get_output_name(int output_index)
        {
            string ret = nrtPINVOKE.Model_get_output_name(swigCPtr, output_index);
            return ret;
        }

        /// @brief Return the ModelIOFlag of the output corresponding to the index argument.\n
        /// @param output_index The index value in the range [0, num_inputs)
        public int get_output_flag(int output_index)
        {
            int ret = nrtPINVOKE.Model_get_output_flag(swigCPtr, output_index);
            return ret;
        }

        /// @brief Returns the number of classes the model outputs.
        public int get_num_classes()
        {
            int ret = nrtPINVOKE.Model_get_num_classes(swigCPtr);
            return ret;
        }

        /// @brief Returns the name of the class corresponding to each class index.
        /// @param class_index The index value in the range [0, num_classes)
        public string get_class_name(int class_index)
        {
            string ret = nrtPINVOKE.Model_get_class_name(swigCPtr, class_index);
            return ret;
        }

        /// @brief The name of the model specified at the start of training
        public string get_model_name()
        {
            string ret = nrtPINVOKE.Model_get_model_name(swigCPtr);
            return ret;
        }

        /// @brief Training type specified at the start of training\n
        /// The return value is one of the following strings :\n
        /// "PC" : Indicates that it has been trained by exploring favorable models priorities for general PCs with GPUs.\n
        ///     Some models are disadvantageous in terms of inference speed in embedded device but may be advantageous in general GPU\n
        ///     This value tells how the model search priorities were set at the start of training and is not information about the last selected model.\n
        /// "EMB" : Indicates that it has been trained by exploring favorable models priorities for he Embedded devices such as Nvidia Jetson\n
        ///     Some models are disadvantageous in terms of inference speed in general GPU but may be advantageous in embedded device\n
        ///     This value tells how the model search priorities were set at the start of training and is not information about the last selected model.
        public string get_training_type()
        {
            string ret = nrtPINVOKE.Model_get_training_type(swigCPtr);
            return ret;
        }

        /// @brief Inference time range of model used in training\n
        /// This value represents the search range in training and is not information about the model finally selected.
        public int get_training_inference_time_level()
        {
            int ret = nrtPINVOKE.Model_get_training_inference_time_level(swigCPtr);
            return ret;
        }

        /// @brief Hyperparameter search range specified at the start of training\n
        /// It has one of {-1, 1, 2, 3}\n
        /// -1 indicates sample search and the rest indicates each search level.
        public int get_training_search_space_level()
        {
            int ret = nrtPINVOKE.Model_get_training_search_space_level(swigCPtr);
            return ret;
        }

        public Status destroy()
        {
            Status ret = (Status)nrtPINVOKE.Model_destroy(swigCPtr);
            return ret;
        }

        ///Indicates  Basic input / output of model
        public static readonly int MODELIO_DEFAULT = nrtPINVOKE.Model_MODELIO_DEFAULT_get();
        ///Indicates image input In the current version, all models use image input, so the value is set by default.
        public static readonly int MODELIO_IN_IMAGE = nrtPINVOKE.Model_MODELIO_IN_IMAGE_get();
        ///Indicates class prediction.
        public static readonly int MODELIO_OUT_PRED = nrtPINVOKE.Model_MODELIO_OUT_PRED_get();
        ///Indicates probability output per class.
        public static readonly int MODELIO_OUT_PROB = nrtPINVOKE.Model_MODELIO_OUT_PROB_get();
        ///Indicates class activation map. Valid only for classification model.
        public static readonly int MODELIO_OUT_CAM = nrtPINVOKE.Model_MODELIO_OUT_CAM_get();

    }

}
namespace nrt
{
    /// @brief Model class\n
    /// Execution class that performs the actual I / O of the model.
    public class Executor : global::System.IDisposable
    {
        private global::System.Runtime.InteropServices.HandleRef swigCPtr;
        protected bool swigCMemOwn;

        internal Executor(global::System.IntPtr cPtr, bool cMemoryOwn)
        {
            swigCMemOwn = cMemoryOwn;
            swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
        }

        internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Executor obj)
        {
            return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
        }

        ~Executor()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            global::System.GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            lock (this)
            {
                if (swigCPtr.Handle != global::System.IntPtr.Zero)
                {
                    if (swigCMemOwn)
                    {
                        swigCMemOwn = false;
                        nrtPINVOKE.delete_Executor(swigCPtr);
                    }
                    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
                }
            }
        }

        /// @brief Constructor
        /// @param model The model object to execute.
        /// @param device The descriptor for the device on which the Executor will run.
        /// @param batch_size The batch size to use for one excution.
        /// @param opt Not used in the current version
        public Executor(Model model, Device device, int batch_size, Dict opt) : this(nrtPINVOKE.new_Executor__SWIG_0(Model.getCPtr(model), Device.getCPtr(device), batch_size, Dict.getCPtr(opt)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        /// @brief Constructor
        /// @param model The model object to execute.
        /// @param device The descriptor for the device on which the Executor will run.
        /// @param batch_size The batch size to use for one excution.
        public Executor(Model model, Device device, int batch_size) : this(nrtPINVOKE.new_Executor__SWIG_1(Model.getCPtr(model), Device.getCPtr(device), batch_size), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        /// @brief Constructor
        /// @param model The model object to execute.
        /// @param device The descriptor for the device on which the Executor will run.
        public Executor(Model model, Device device) : this(nrtPINVOKE.new_Executor__SWIG_2(Model.getCPtr(model), Device.getCPtr(device)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }

        public Executor(Executor src) : this(nrtPINVOKE.new_Executor__SWIG_3(Executor.getCPtr(src)), true)
        {
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
        }
        /// @brief Perform prediction through executor.\n
        /// The execute function to use when there is only one model input (when the get_num_inputs return value of the Model object is 1).
        /// @param input Input data. The DType and Shape must be the same as the values checked by get_input_shape (0) and get_input_dtype (0) in the Model object.\n
        /// If the size of the original input and the input size of the model are different, the patching or resizing must be performed according to the value of the model's is_patch_mode() method.\n
        /// Check the is_patch_mode() method documentation for details.
        /// @param outputs Execution result output. If there are multiple output values, the order in NDBufferList is the same as the order found in the model object,\n
        ///and you can check which output values through get_output_shape, get_output_dtype, and get_output_flag.
        public Status execute(NDBuffer input, NDBufferList outputs)
        {
            Status ret = (Status)nrtPINVOKE.Executor_execute__SWIG_0(swigCPtr, NDBuffer.getCPtr(input), NDBufferList.getCPtr(outputs));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }
        /// @brief Perform prediction through executor.\n
        /// @param inputs Input data. The number of NDBuffers in the NDBufferList is the same as the value checked by get_num_inputs on the model object.\n
        /// The type and shape of each NDBuffer can be checked with get_input_shape and get_input_dtype.\n
        /// When operating in batch units, the first axis of the shape of the input NDBuffer indicates the batch, and the rest must be the same as the shape that can be checked with get_input_shape.
        /// If the size of the original input and the input size of the model are different, the patching or resizing must be performed according to the value of the model's is_patch_mode() method.\n
        /// Check the is_patch_mode() method documentation for details.
        /// @param outputs Execution result output. If there are multiple output values, the order in NDBufferList is the same as the order found in the model object,\n
        /// and you can check which output values through get_output_shape, get_output_dtype, and get_output_flag.
        public Status execute(NDBufferList inputs, NDBufferList outputs)
        {
            Status ret = (Status)nrtPINVOKE.Executor_execute__SWIG_1(swigCPtr, NDBufferList.getCPtr(inputs), NDBufferList.getCPtr(outputs));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public Status get_status()
        {
            Status ret = (Status)nrtPINVOKE.Executor_get_status(swigCPtr);
            return ret;
        }

        public Status destroy()
        {
            Status ret = (Status)nrtPINVOKE.Executor_destroy(swigCPtr);
            return ret;
        }

    }

}
namespace nrt
{

    class nrtPINVOKE
    {

        protected class SWIGExceptionHelper
        {

            public delegate void ExceptionDelegate(string message);
            public delegate void ExceptionArgumentDelegate(string message, string paramName);

            static ExceptionDelegate applicationDelegate = new ExceptionDelegate(SetPendingApplicationException);
            static ExceptionDelegate arithmeticDelegate = new ExceptionDelegate(SetPendingArithmeticException);
            static ExceptionDelegate divideByZeroDelegate = new ExceptionDelegate(SetPendingDivideByZeroException);
            static ExceptionDelegate indexOutOfRangeDelegate = new ExceptionDelegate(SetPendingIndexOutOfRangeException);
            static ExceptionDelegate invalidCastDelegate = new ExceptionDelegate(SetPendingInvalidCastException);
            static ExceptionDelegate invalidOperationDelegate = new ExceptionDelegate(SetPendingInvalidOperationException);
            static ExceptionDelegate ioDelegate = new ExceptionDelegate(SetPendingIOException);
            static ExceptionDelegate nullReferenceDelegate = new ExceptionDelegate(SetPendingNullReferenceException);
            static ExceptionDelegate outOfMemoryDelegate = new ExceptionDelegate(SetPendingOutOfMemoryException);
            static ExceptionDelegate overflowDelegate = new ExceptionDelegate(SetPendingOverflowException);
            static ExceptionDelegate systemDelegate = new ExceptionDelegate(SetPendingSystemException);

            static ExceptionArgumentDelegate argumentDelegate = new ExceptionArgumentDelegate(SetPendingArgumentException);
            static ExceptionArgumentDelegate argumentNullDelegate = new ExceptionArgumentDelegate(SetPendingArgumentNullException);
            static ExceptionArgumentDelegate argumentOutOfRangeDelegate = new ExceptionArgumentDelegate(SetPendingArgumentOutOfRangeException);

            [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "SWIGRegisterExceptionCallbacks_nrt")]
            public static extern void SWIGRegisterExceptionCallbacks_nrt(
                                        ExceptionDelegate applicationDelegate,
                                        ExceptionDelegate arithmeticDelegate,
                                        ExceptionDelegate divideByZeroDelegate,
                                        ExceptionDelegate indexOutOfRangeDelegate,
                                        ExceptionDelegate invalidCastDelegate,
                                        ExceptionDelegate invalidOperationDelegate,
                                        ExceptionDelegate ioDelegate,
                                        ExceptionDelegate nullReferenceDelegate,
                                        ExceptionDelegate outOfMemoryDelegate,
                                        ExceptionDelegate overflowDelegate,
                                        ExceptionDelegate systemExceptionDelegate);

            [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "SWIGRegisterExceptionArgumentCallbacks_nrt")]
            public static extern void SWIGRegisterExceptionCallbacksArgument_nrt(
                                        ExceptionArgumentDelegate argumentDelegate,
                                        ExceptionArgumentDelegate argumentNullDelegate,
                                        ExceptionArgumentDelegate argumentOutOfRangeDelegate);

            static void SetPendingApplicationException(string message)
            {
                SWIGPendingException.Set(new global::System.ApplicationException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingArithmeticException(string message)
            {
                SWIGPendingException.Set(new global::System.ArithmeticException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingDivideByZeroException(string message)
            {
                SWIGPendingException.Set(new global::System.DivideByZeroException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingIndexOutOfRangeException(string message)
            {
                SWIGPendingException.Set(new global::System.IndexOutOfRangeException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingInvalidCastException(string message)
            {
                SWIGPendingException.Set(new global::System.InvalidCastException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingInvalidOperationException(string message)
            {
                SWIGPendingException.Set(new global::System.InvalidOperationException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingIOException(string message)
            {
                SWIGPendingException.Set(new global::System.IO.IOException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingNullReferenceException(string message)
            {
                SWIGPendingException.Set(new global::System.NullReferenceException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingOutOfMemoryException(string message)
            {
                SWIGPendingException.Set(new global::System.OutOfMemoryException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingOverflowException(string message)
            {
                SWIGPendingException.Set(new global::System.OverflowException(message, SWIGPendingException.Retrieve()));
            }
            static void SetPendingSystemException(string message)
            {
                SWIGPendingException.Set(new global::System.SystemException(message, SWIGPendingException.Retrieve()));
            }

            static void SetPendingArgumentException(string message, string paramName)
            {
                SWIGPendingException.Set(new global::System.ArgumentException(message, paramName, SWIGPendingException.Retrieve()));
            }
            static void SetPendingArgumentNullException(string message, string paramName)
            {
                global::System.Exception e = SWIGPendingException.Retrieve();
                if (e != null) message = message + " Inner Exception: " + e.Message;
                SWIGPendingException.Set(new global::System.ArgumentNullException(paramName, message));
            }
            static void SetPendingArgumentOutOfRangeException(string message, string paramName)
            {
                global::System.Exception e = SWIGPendingException.Retrieve();
                if (e != null) message = message + " Inner Exception: " + e.Message;
                SWIGPendingException.Set(new global::System.ArgumentOutOfRangeException(paramName, message));
            }

            static SWIGExceptionHelper()
            {
                SWIGRegisterExceptionCallbacks_nrt(
                                          applicationDelegate,
                                          arithmeticDelegate,
                                          divideByZeroDelegate,
                                          indexOutOfRangeDelegate,
                                          invalidCastDelegate,
                                          invalidOperationDelegate,
                                          ioDelegate,
                                          nullReferenceDelegate,
                                          outOfMemoryDelegate,
                                          overflowDelegate,
                                          systemDelegate);

                SWIGRegisterExceptionCallbacksArgument_nrt(
                                          argumentDelegate,
                                          argumentNullDelegate,
                                          argumentOutOfRangeDelegate);
            }
        }

        protected static SWIGExceptionHelper swigExceptionHelper = new SWIGExceptionHelper();

        public class SWIGPendingException
        {
            [global::System.ThreadStatic]
            private static global::System.Exception pendingException = null;
            private static int numExceptionsPending = 0;
            private static global::System.Object exceptionsLock = null;

            public static bool Pending
            {
                get
                {
                    bool pending = false;
                    if (numExceptionsPending > 0)
                        if (pendingException != null)
                            pending = true;
                    return pending;
                }
            }

            public static void Set(global::System.Exception e)
            {
                if (pendingException != null)
                    throw new global::System.ApplicationException("FATAL: An earlier pending exception from unmanaged code was missed and thus not thrown (" + pendingException.ToString() + ")", e);
                pendingException = e;
                lock (exceptionsLock)
                {
                    numExceptionsPending++;
                }
            }

            public static global::System.Exception Retrieve()
            {
                global::System.Exception e = null;
                if (numExceptionsPending > 0)
                {
                    if (pendingException != null)
                    {
                        e = pendingException;
                        pendingException = null;
                        lock (exceptionsLock)
                        {
                            numExceptionsPending--;
                        }
                    }
                }
                return e;
            }

            static SWIGPendingException()
            {
                exceptionsLock = new global::System.Object();
            }
        }


        protected class SWIGStringHelper
        {

            public delegate string SWIGStringDelegate(string message);
            static SWIGStringDelegate stringDelegate = new SWIGStringDelegate(CreateString);

            [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "SWIGRegisterStringCallback_nrt")]
            public static extern void SWIGRegisterStringCallback_nrt(SWIGStringDelegate stringDelegate);

            static string CreateString(string cString)
            {
                return cString;
            }

            static SWIGStringHelper()
            {
                SWIGRegisterStringCallback_nrt(stringDelegate);
            }
        }

        static protected SWIGStringHelper swigStringHelper = new SWIGStringHelper();


        static nrtPINVOKE()
        {
        }


        protected class SWIGWStringHelper
        {

            [return: global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)]
            public delegate string SWIGWStringDelegate(global::System.IntPtr message);
            static SWIGWStringDelegate wstringDelegate = new SWIGWStringDelegate(CreateWString);

            [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "SWIGRegisterWStringCallback_nrt")]
            public static extern void SWIGRegisterWStringCallback_nrt(SWIGWStringDelegate wstringDelegate);

            static string CreateWString([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] global::System.IntPtr cString)
            {
                return global::System.Runtime.InteropServices.Marshal.PtrToStringUni(cString);
            }

            static SWIGWStringHelper()
            {
                SWIGRegisterWStringCallback_nrt(wstringDelegate);
            }
        }

        static protected SWIGWStringHelper swigWStringHelper = new SWIGWStringHelper();


        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NRT_MIN_IMG_HW_get")]
        public static extern int NRT_MIN_IMG_HW_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NRT_MAX_IMG_C_get")]
        public static extern int NRT_MAX_IMG_C_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NRT_KEY_WORKSPACE_SIZE_get")]
        public static extern string NRT_KEY_WORKSPACE_SIZE_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_dtype_to_str")]
        public static extern string dtype_to_str(int jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_DIM_UNKNOWN_get")]
        public static extern int Shape_DIM_UNKNOWN_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_MAX_DIM_get")]
        public static extern int Shape_MAX_DIM_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Shape__SWIG_0")]
        public static extern global::System.IntPtr new_Shape__SWIG_0();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Shape__SWIG_1")]
        public static extern global::System.IntPtr new_Shape__SWIG_1(int jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Shape__SWIG_2")]
        public static extern global::System.IntPtr new_Shape__SWIG_2(int jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Shape__SWIG_3")]
        public static extern global::System.IntPtr new_Shape__SWIG_3(int jarg1, int jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Shape__SWIG_4")]
        public static extern global::System.IntPtr new_Shape__SWIG_4(int jarg1, int jarg2, int jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_get_axis")]
        public static extern int Shape_get_axis(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_set_axis")]
        public static extern void Shape_set_axis(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_to_batch_shape")]
        public static extern global::System.IntPtr Shape_to_batch_shape(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_num_dim_set")]
        public static extern void Shape_num_dim_set(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Shape_num_dim_get")]
        public static extern int Shape_num_dim_get(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_Shape")]
        public static extern void delete_Shape(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_0")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_0();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_1")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, bool jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_2")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_2(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_3")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_3(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_4")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_4([global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg1, ulong jarg2, global::System.Runtime.InteropServices.HandleRef jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_5")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_5([global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg1, ulong jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_zeros")]
        public static extern global::System.IntPtr NDBuffer_zeros(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_make_size_thres")]
        public static extern global::System.IntPtr NDBuffer_make_size_thres(int jarg1, int jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_NDBuffer")]
        public static extern void delete_NDBuffer(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBuffer__SWIG_6")]
        public static extern global::System.IntPtr new_NDBuffer__SWIG_6(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_total_size")]
        public static extern ulong NDBuffer_get_total_size(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_byte_size")]
        public static extern ulong NDBuffer_get_byte_size(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_data_ptr")]
        public static extern global::System.IntPtr NDBuffer_get_data_ptr(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_at_ptr__SWIG_0")]
        public static extern global::System.IntPtr NDBuffer_get_at_ptr__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, int jarg3, int jarg4, int jarg5);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_at_ptr__SWIG_1")]
        public static extern global::System.IntPtr NDBuffer_get_at_ptr__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, int jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_at_ptr__SWIG_2")]
        public static extern global::System.IntPtr NDBuffer_get_at_ptr__SWIG_2(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_at_ptr__SWIG_3")]
        public static extern global::System.IntPtr NDBuffer_get_at_ptr__SWIG_3(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_at_ptr__SWIG_4")]
        public static extern global::System.IntPtr NDBuffer_get_at_ptr__SWIG_4(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_dtype")]
        public static extern int NDBuffer_get_dtype(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_get_shape")]
        public static extern global::System.IntPtr NDBuffer_get_shape(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_clone")]
        public static extern global::System.IntPtr NDBuffer_clone(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_reset__SWIG_0")]
        public static extern void NDBuffer_reset__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_reset__SWIG_1")]
        public static extern void NDBuffer_reset__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_empty")]
        public static extern bool NDBuffer_empty(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_int64")]
        public static extern global::System.IntPtr NDBuffer_int64(long jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_load_image")]
        public static extern global::System.IntPtr NDBuffer_load_image([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] string jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_load_images__SWIG_0")]
        public static extern global::System.IntPtr NDBuffer_load_images__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] string jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_load_images__SWIG_1")]
        public static extern global::System.IntPtr NDBuffer_load_images__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] string jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer__dbg_show")]
        public static extern void NDBuffer__dbg_show(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer__dbg_colormap_show")]
        public static extern void NDBuffer__dbg_colormap_show(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint8__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_uint8__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint8__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_uint8__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int16__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_int16__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] short[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int16__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_int16__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] short[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint16__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_uint16__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ushort[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint16__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_uint16__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ushort[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int32__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_int32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] int[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int32__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_int32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] int[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint32__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_uint32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] uint[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint32__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_uint32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] uint[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int64__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_int64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] long[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_int64__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_int64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] long[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint64__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_uint64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ulong[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_uint64__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_uint64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ulong[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_float32__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_float32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] float[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_float32__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_float32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] float[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_float64__SWIG_0")]
        public static extern int NDBuffer_copy_from_buffer_float64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] double[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_from_buffer_float64__SWIG_1")]
        public static extern int NDBuffer_copy_from_buffer_float64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] double[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint8__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_uint8__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint8__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_uint8__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] byte[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int16__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_int16__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] short[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int16__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_int16__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] short[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint16__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_uint16__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ushort[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint16__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_uint16__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ushort[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int32__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_int32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] int[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int32__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_int32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] int[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint32__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_uint32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] uint[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint32__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_uint32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] uint[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int64__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_int64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] long[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_int64__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_int64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] long[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint64__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_uint64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ulong[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_uint64__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_uint64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] ulong[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_float32__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_float32__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] float[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_float32__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_float32__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] float[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_float64__SWIG_0")]
        public static extern int NDBuffer_copy_to_buffer_float64__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] double[] jarg2, ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBuffer_copy_to_buffer_float64__SWIG_1")]
        public static extern int NDBuffer_copy_to_buffer_float64__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2, [global::System.Runtime.InteropServices.In, global::System.Runtime.InteropServices.Out, global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPArray)] double[] jarg3, ulong jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBufferList__SWIG_0")]
        public static extern global::System.IntPtr new_NDBufferList__SWIG_0();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_NDBufferList")]
        public static extern void delete_NDBufferList(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_NDBufferList__SWIG_1")]
        public static extern global::System.IntPtr new_NDBufferList__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_get_count")]
        public static extern ulong NDBufferList_get_count(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_append")]
        public static extern void NDBufferList_append(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_get_at__SWIG_0")]
        public static extern global::System.IntPtr NDBufferList_get_at__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_get_data_ptr__SWIG_0")]
        public static extern global::System.IntPtr NDBufferList_get_data_ptr__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_resize")]
        public static extern void NDBufferList_resize(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_NDBufferList_clear")]
        public static extern void NDBufferList_clear(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_get_dtype_elemsize")]
        public static extern int get_dtype_elemsize(int jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_devtype_set")]
        public static extern void Device_devtype_set(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_devtype_get")]
        public static extern int Device_devtype_get(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_id_set")]
        public static extern void Device_id_set(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_id_get")]
        public static extern int Device_id_get(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_get_num_devices")]
        public static extern int Device_get_num_devices();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_get_device")]
        public static extern global::System.IntPtr Device_get_device(int jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_get_num_gpu_devices")]
        public static extern int Device_get_num_gpu_devices();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_get_gpu_mem_info")]
        public static extern int Device_get_gpu_mem_info(int jarg1, ref ulong jarg2, ref ulong jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Device_get_device_name")]
        public static extern string Device_get_device_name(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Device")]
        public static extern global::System.IntPtr new_Device();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_Device")]
        public static extern void delete_Device(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Dict__SWIG_0")]
        public static extern global::System.IntPtr new_Dict__SWIG_0();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_Dict")]
        public static extern void delete_Dict(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Dict__SWIG_1")]
        public static extern global::System.IntPtr new_Dict__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_put")]
        public static extern int Dict_put(global::System.Runtime.InteropServices.HandleRef jarg1, string jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_has_key")]
        public static extern bool Dict_has_key(global::System.Runtime.InteropServices.HandleRef jarg1, string jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_get")]
        public static extern global::System.IntPtr Dict_get(global::System.Runtime.InteropServices.HandleRef jarg1, string jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_remove")]
        public static extern int Dict_remove(global::System.Runtime.InteropServices.HandleRef jarg1, string jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_get_count")]
        public static extern ulong Dict_get_count(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Dict_clear")]
        public static extern void Dict_clear(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_zero_padding__SWIG_0")]
        public static extern int zero_padding__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_zero_padding__SWIG_1")]
        public static extern int zero_padding__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_resize__SWIG_0")]
        public static extern int resize__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_resize__SWIG_1")]
        public static extern int resize__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_resize__SWIG_2")]
        public static extern int resize__SWIG_2(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, float jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_resize__SWIG_3")]
        public static extern int resize__SWIG_3(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, float jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_extract_patches_to_target_shape")]
        public static extern int extract_patches_to_target_shape(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3, global::System.Runtime.InteropServices.HandleRef jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_merge_patches_to_orginal_shape")]
        public static extern int merge_patches_to_orginal_shape(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_pred_map_threshold_by_size")]
        public static extern int pred_map_threshold_by_size(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3, int jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_prob_map_threshold")]
        public static extern int prob_map_threshold(global::System.Runtime.InteropServices.HandleRef jarg1, float jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_convert_to_colormap")]
        public static extern int convert_to_colormap(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_MODELIO_DEFAULT_get")]
        public static extern int Model_MODELIO_DEFAULT_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_MODELIO_IN_IMAGE_get")]
        public static extern int Model_MODELIO_IN_IMAGE_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_MODELIO_OUT_PRED_get")]
        public static extern int Model_MODELIO_OUT_PRED_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_MODELIO_OUT_PROB_get")]
        public static extern int Model_MODELIO_OUT_PROB_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_MODELIO_OUT_CAM_get")]
        public static extern int Model_MODELIO_OUT_CAM_get();

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Model__SWIG_0")]
        public static extern global::System.IntPtr new_Model__SWIG_0([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] string jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Model__SWIG_1")]
        public static extern global::System.IntPtr new_Model__SWIG_1([global::System.Runtime.InteropServices.MarshalAs(global::System.Runtime.InteropServices.UnmanagedType.LPWStr)] string jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_Model")]
        public static extern void delete_Model(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Model__SWIG_2")]
        public static extern global::System.IntPtr new_Model__SWIG_2(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_model_type")]
        public static extern int Model_get_model_type(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_status")]
        public static extern int Model_get_status(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_num_inputs")]
        public static extern int Model_get_num_inputs(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_input_shape")]
        public static extern global::System.IntPtr Model_get_input_shape(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_input_dtype")]
        public static extern int Model_get_input_dtype(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_input_name")]
        public static extern string Model_get_input_name(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_InterpolationType")]
        public static extern int Model_get_InterpolationType(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_is_patch_mode")]
        public static extern bool Model_is_patch_mode(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_scale_factor")]
        public static extern float Model_get_scale_factor(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_num_outputs")]
        public static extern int Model_get_num_outputs(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_output_shape")]
        public static extern global::System.IntPtr Model_get_output_shape(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_output_dtype")]
        public static extern int Model_get_output_dtype(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_output_name")]
        public static extern string Model_get_output_name(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_output_flag")]
        public static extern int Model_get_output_flag(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_num_classes")]
        public static extern int Model_get_num_classes(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_class_name")]
        public static extern string Model_get_class_name(global::System.Runtime.InteropServices.HandleRef jarg1, int jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_model_name")]
        public static extern string Model_get_model_name(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_training_type")]
        public static extern string Model_get_training_type(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_training_inference_time_level")]
        public static extern int Model_get_training_inference_time_level(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_get_training_search_space_level")]
        public static extern int Model_get_training_search_space_level(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Model_destroy")]
        public static extern int Model_destroy(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Executor__SWIG_0")]
        public static extern global::System.IntPtr new_Executor__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, int jarg3, global::System.Runtime.InteropServices.HandleRef jarg4);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Executor__SWIG_1")]
        public static extern global::System.IntPtr new_Executor__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, int jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Executor__SWIG_2")]
        public static extern global::System.IntPtr new_Executor__SWIG_2(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_delete_Executor")]
        public static extern void delete_Executor(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_new_Executor__SWIG_3")]
        public static extern global::System.IntPtr new_Executor__SWIG_3(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Executor_execute__SWIG_0")]
        public static extern int Executor_execute__SWIG_0(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Executor_execute__SWIG_1")]
        public static extern int Executor_execute__SWIG_1(global::System.Runtime.InteropServices.HandleRef jarg1, global::System.Runtime.InteropServices.HandleRef jarg2, global::System.Runtime.InteropServices.HandleRef jarg3);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Executor_get_status")]
        public static extern int Executor_get_status(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_Executor_destroy")]
        public static extern int Executor_destroy(global::System.Runtime.InteropServices.HandleRef jarg1);

        [global::System.Runtime.InteropServices.DllImport("nrt", EntryPoint = "CSharp_nrt_get_last_error_msg")]
        public static extern string get_last_error_msg();
    }

}
namespace nrt
{

    public class nrt
    {
        public static string dtype_to_str(DType dtype)
        {
            string ret = nrtPINVOKE.dtype_to_str((int)dtype);
            return ret;
        }

        public static int get_dtype_elemsize(DType d)
        {
            int ret = nrtPINVOKE.get_dtype_elemsize((int)d);
            return ret;
        }

        public static Status zero_padding(NDBuffer inputs, NDBuffer outputs, Shape target_shape, PaddingOpt padd_opt)
        {
            Status ret = (Status)nrtPINVOKE.zero_padding__SWIG_0(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), Shape.getCPtr(target_shape), (int)padd_opt);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        public static Status zero_padding(NDBuffer inputs, NDBuffer outputs, Shape target_shape)
        {
            Status ret = (Status)nrtPINVOKE.zero_padding__SWIG_1(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), Shape.getCPtr(target_shape));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }


        /// @brief Resize NDBuffer Image
        /// @param inputs Input image buffer
        /// Can receive multiple images as input
        ///	The size and channel of each image must be the same, then shape should be equal to [number_of_image, height, width, channel]
        /// @param outputs Output Resize Results 
        /// The value of the first dimension axis of the shape is equal to the number of input images, and the remaining values become the shape specified by target_shape.
        /// @param target_shape  Target shape value to resize. It must be three-dimensional and have the form [height, width, channel]
        /// @param interpol_ty Indicates the interpolation method to use for resize.
        public static Status resize(NDBuffer inputs, NDBuffer outputs, Shape target_shape, InterpolationType interpol_ty)
        {
            Status ret = (Status)nrtPINVOKE.resize__SWIG_0(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), Shape.getCPtr(target_shape), (int)interpol_ty);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Resize NDBuffer Image
        /// @param inputs Input image buffer
        /// Can receive multiple images as input
        ///	The size and channel of each image must be the same, then shape should be equal to [number_of_image, height, width, channel]
        /// @param outputs Output Resize Results 
        /// The value of the first dimension axis of the shape is equal to the number of input images, and the remaining values become the shape specified by target_shape.
        /// @param target_shape  Target shape value to resize. It must be three-dimensional and have the form [height, width, channel]
        public static Status resize(NDBuffer inputs, NDBuffer outputs, Shape target_shape)
        {
            Status ret = (Status)nrtPINVOKE.resize__SWIG_1(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), Shape.getCPtr(target_shape));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Resize NDBuffer Image with scale_factor
        /// @param inputs Input image buffer
        /// Can receive multiple images as input
        ///	The size and channel of each image must be the same, then shape should be equal to [number_of_image, height, width, channel]
        /// @param outputs Resize Results 
        /// @param scale_factor  This value is multiplied by the height and width of the input image to determine the shape of the output image.
        /// @param interpol_ty Indicates the interpolation method to use for resize.
        public static Status resize(NDBuffer inputs, NDBuffer outputs, float scale_factor, InterpolationType interpol_ty)
        {
            Status ret = (Status)nrtPINVOKE.resize__SWIG_2(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), scale_factor, (int)interpol_ty);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Resize NDBuffer Image with scale_factor
        /// @param inputs Input image buffer
        /// Can receive multiple images as input
        ///	The size and channel of each image must be the same, then shape should be equal to [number_of_image, height, width, channel]
        /// @param outputs Resize Results 
        /// @param scale_factor  This value is multiplied by the height and width of the input image to determine the shape of the output image.
        public static Status resize(NDBuffer inputs, NDBuffer outputs, float scale_factor)
        {
            Status ret = (Status)nrtPINVOKE.resize__SWIG_3(NDBuffer.getCPtr(inputs), NDBuffer.getCPtr(outputs), scale_factor);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Patch the original image to fit the model input value. This is only used if the value of is_patch_mode () of the model object is true.
        /// @param images The shape of the input must be [number_of_image, height, width, channel] or [number_of_image, height, width]
        /// @param target_shape Indicates patch size. Must be [patch_height, patch_width, channel] or [patch_height, patch_width]
        /// @param out_patches Output split into patches. 
        /// @param out_patch_info Output information to this variable about which image's patch it came from and at what position (x, y).
        public static Status extract_patches_to_target_shape(NDBuffer images, Shape target_shape, NDBuffer out_patches, NDBuffer out_patch_info)
        {
            Status ret = (Status)nrtPINVOKE.extract_patches_to_target_shape(NDBuffer.getCPtr(images), Shape.getCPtr(target_shape), NDBuffer.getCPtr(out_patches), NDBuffer.getCPtr(out_patch_info));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Used to restore patches to their original image shape. This is only used if the value of is_patch_mode () of the model object is true.
        /// @param patches The shape of the input must be [number_of_patch, height, width, channel] or [number_of_patch, height, width]
        /// @param patch_info Data structure representing the image and location of a patch. Use out_patch_info as a result of the extract_patches_to_target_shape function.
        /// @param out_image Output of results merged to the original image size.
        public static Status merge_patches_to_orginal_shape(NDBuffer patches, NDBuffer patch_info, NDBuffer out_image)
        {
            Status ret = (Status)nrtPINVOKE.merge_patches_to_orginal_shape(NDBuffer.getCPtr(patches), NDBuffer.getCPtr(patch_info), NDBuffer.getCPtr(out_image));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Filter the resulting area of the segmentation prediction map by the height width threshold.
        /// @param pred_map It is primarily a prediction map, which is the result of execution of the segmentation model, or data that merges the result of the prediction map of a patch into the original image size as input.
        /// @param bounding_rects  Outputs the bouding rect of the prediction map, excluding the background area.\n
        /// The shape of bounding_rects is as follows : [n, 6]\n
        ///	The six values in the second dimension are :\n
        /// 0 : batch index(if four - dimensional batch image shape[n, height, width, channel]) for the input image_buff\n
        /// 1 : Upper left x coordinate of detection area rectangle\n
        /// 2 : Upper left y coordinate of detection area rectangle\n
        /// 3 : Height of detection area rectangle\n
        /// 4 : Width of detection area rectangle\n
        /// 5 : Class index of the detection area rectangle\n
        /// @param size_thres Specifies the size threshold input. The shape must be  [3] or [num_classes, 3], and the dtype of size_thres must be DTYPE_INT32.\n
        /// Each of the thress values of last axis is height_thres, width_thres and thres_cond.\n
        /// The meaning of each value is as follows.\n
        /// height_thres : Height threshold\n
        /// width_thres : Width threshold\n
        /// thres_cond\n
        ///    Case thres_cond == 0, it changes to background when the size of the detected area satisfies both height_thres and width_thres. (AND condition)\n
        ///	   Case thres_cond == 1, it changes to the background area when the size of the detected area satisfies either height_thres or width_thres. (OR condition)\n
        /// @param num_classes Represents the total number of classes represented in the prediction map.
        public static Status pred_map_threshold_by_size(NDBuffer pred_map, NDBuffer bounding_rects, NDBuffer size_thres, int num_classes)
        {
            Status ret = (Status)nrtPINVOKE.pred_map_threshold_by_size(NDBuffer.getCPtr(pred_map), NDBuffer.getCPtr(bounding_rects), NDBuffer.getCPtr(size_thres), num_classes);
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Apply threshold for classification probability vectors.\n
        /// If the highest probability class has a lower probability than Threshold, the result is returned as Unknown.
        /// @param prob_map Probability vector resulting from classification prediction, which has a shape of [batch_size, number_of_classes].
        /// @param prob_thres Specifies the threshold value, which must be in the range (0, 1).
        /// @param result_classes Outputs thresholded classifation results. The result_classes is returned as shape of [batch_size, 1].\n
        /// If the highest probability class has a lower probability than Threshold, the result is returned as Unknown.\n 
        /// Unknown class is represented by a value of -1.
        public static Status prob_map_threshold(NDBuffer prob_map, float prob_thres, NDBuffer result_classes)
        {
            Status ret = (Status)nrtPINVOKE.prob_map_threshold(NDBuffer.getCPtr(prob_map), prob_thres, NDBuffer.getCPtr(result_classes));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief The input image is output by applying a color map.\n
        /// input_images must be an NDbuffer object that is a single image of a 3D shape or multiple images of a 4D shape.\n
        /// In the current version, only 1 or 3 channel images of DTYPE_UINT8 type can be input.
        public static Status convert_to_colormap(NDBuffer input_images, NDBuffer output_images)
        {
            Status ret = (Status)nrtPINVOKE.convert_to_colormap(NDBuffer.getCPtr(input_images), NDBuffer.getCPtr(output_images));
            if (nrtPINVOKE.SWIGPendingException.Pending) throw nrtPINVOKE.SWIGPendingException.Retrieve();
            return ret;
        }

        /// @brief Perform prediction through executor.\n
        /// If the recent NRT API call fails and returns an error status, the string for the cause of the error is returned.
        public static string get_last_error_msg()
        {
            string ret = nrtPINVOKE.get_last_error_msg();
            return ret;
        }

        public static readonly int NRT_MIN_IMG_HW = nrtPINVOKE.NRT_MIN_IMG_HW_get();
        public static readonly int NRT_MAX_IMG_C = nrtPINVOKE.NRT_MAX_IMG_C_get();
        public static readonly string NRT_KEY_WORKSPACE_SIZE = nrtPINVOKE.NRT_KEY_WORKSPACE_SIZE_get();
    }

}
